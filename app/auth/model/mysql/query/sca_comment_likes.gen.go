// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"schisandra-album-cloud-microservices/app/auth/model/mysql/model"
)

func newScaCommentLike(db *gorm.DB, opts ...gen.DOOption) scaCommentLike {
	_scaCommentLike := scaCommentLike{}

	_scaCommentLike.scaCommentLikeDo.UseDB(db, opts...)
	_scaCommentLike.scaCommentLikeDo.UseModel(&model.ScaCommentLike{})

	tableName := _scaCommentLike.scaCommentLikeDo.TableName()
	_scaCommentLike.ALL = field.NewAsterisk(tableName)
	_scaCommentLike.ID = field.NewInt64(tableName, "id")
	_scaCommentLike.TopicID = field.NewString(tableName, "topic_id")
	_scaCommentLike.UserID = field.NewString(tableName, "user_id")
	_scaCommentLike.CommentID = field.NewInt64(tableName, "comment_id")
	_scaCommentLike.LikeTime = field.NewTime(tableName, "like_time")

	_scaCommentLike.fillFieldMap()

	return _scaCommentLike
}

// scaCommentLike 评论点赞表
type scaCommentLike struct {
	scaCommentLikeDo

	ALL       field.Asterisk
	ID        field.Int64  // 主键id
	TopicID   field.String // 话题ID
	UserID    field.String // 用户ID
	CommentID field.Int64  // 评论ID
	LikeTime  field.Time   // 点赞时间

	fieldMap map[string]field.Expr
}

func (s scaCommentLike) Table(newTableName string) *scaCommentLike {
	s.scaCommentLikeDo.UseTable(newTableName)
	return s.updateTableName(newTableName)
}

func (s scaCommentLike) As(alias string) *scaCommentLike {
	s.scaCommentLikeDo.DO = *(s.scaCommentLikeDo.As(alias).(*gen.DO))
	return s.updateTableName(alias)
}

func (s *scaCommentLike) updateTableName(table string) *scaCommentLike {
	s.ALL = field.NewAsterisk(table)
	s.ID = field.NewInt64(table, "id")
	s.TopicID = field.NewString(table, "topic_id")
	s.UserID = field.NewString(table, "user_id")
	s.CommentID = field.NewInt64(table, "comment_id")
	s.LikeTime = field.NewTime(table, "like_time")

	s.fillFieldMap()

	return s
}

func (s *scaCommentLike) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := s.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (s *scaCommentLike) fillFieldMap() {
	s.fieldMap = make(map[string]field.Expr, 5)
	s.fieldMap["id"] = s.ID
	s.fieldMap["topic_id"] = s.TopicID
	s.fieldMap["user_id"] = s.UserID
	s.fieldMap["comment_id"] = s.CommentID
	s.fieldMap["like_time"] = s.LikeTime
}

func (s scaCommentLike) clone(db *gorm.DB) scaCommentLike {
	s.scaCommentLikeDo.ReplaceConnPool(db.Statement.ConnPool)
	return s
}

func (s scaCommentLike) replaceDB(db *gorm.DB) scaCommentLike {
	s.scaCommentLikeDo.ReplaceDB(db)
	return s
}

type scaCommentLikeDo struct{ gen.DO }

type IScaCommentLikeDo interface {
	gen.SubQuery
	Debug() IScaCommentLikeDo
	WithContext(ctx context.Context) IScaCommentLikeDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IScaCommentLikeDo
	WriteDB() IScaCommentLikeDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IScaCommentLikeDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IScaCommentLikeDo
	Not(conds ...gen.Condition) IScaCommentLikeDo
	Or(conds ...gen.Condition) IScaCommentLikeDo
	Select(conds ...field.Expr) IScaCommentLikeDo
	Where(conds ...gen.Condition) IScaCommentLikeDo
	Order(conds ...field.Expr) IScaCommentLikeDo
	Distinct(cols ...field.Expr) IScaCommentLikeDo
	Omit(cols ...field.Expr) IScaCommentLikeDo
	Join(table schema.Tabler, on ...field.Expr) IScaCommentLikeDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IScaCommentLikeDo
	RightJoin(table schema.Tabler, on ...field.Expr) IScaCommentLikeDo
	Group(cols ...field.Expr) IScaCommentLikeDo
	Having(conds ...gen.Condition) IScaCommentLikeDo
	Limit(limit int) IScaCommentLikeDo
	Offset(offset int) IScaCommentLikeDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IScaCommentLikeDo
	Unscoped() IScaCommentLikeDo
	Create(values ...*model.ScaCommentLike) error
	CreateInBatches(values []*model.ScaCommentLike, batchSize int) error
	Save(values ...*model.ScaCommentLike) error
	First() (*model.ScaCommentLike, error)
	Take() (*model.ScaCommentLike, error)
	Last() (*model.ScaCommentLike, error)
	Find() ([]*model.ScaCommentLike, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ScaCommentLike, err error)
	FindInBatches(result *[]*model.ScaCommentLike, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.ScaCommentLike) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IScaCommentLikeDo
	Assign(attrs ...field.AssignExpr) IScaCommentLikeDo
	Joins(fields ...field.RelationField) IScaCommentLikeDo
	Preload(fields ...field.RelationField) IScaCommentLikeDo
	FirstOrInit() (*model.ScaCommentLike, error)
	FirstOrCreate() (*model.ScaCommentLike, error)
	FindByPage(offset int, limit int) (result []*model.ScaCommentLike, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IScaCommentLikeDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (s scaCommentLikeDo) Debug() IScaCommentLikeDo {
	return s.withDO(s.DO.Debug())
}

func (s scaCommentLikeDo) WithContext(ctx context.Context) IScaCommentLikeDo {
	return s.withDO(s.DO.WithContext(ctx))
}

func (s scaCommentLikeDo) ReadDB() IScaCommentLikeDo {
	return s.Clauses(dbresolver.Read)
}

func (s scaCommentLikeDo) WriteDB() IScaCommentLikeDo {
	return s.Clauses(dbresolver.Write)
}

func (s scaCommentLikeDo) Session(config *gorm.Session) IScaCommentLikeDo {
	return s.withDO(s.DO.Session(config))
}

func (s scaCommentLikeDo) Clauses(conds ...clause.Expression) IScaCommentLikeDo {
	return s.withDO(s.DO.Clauses(conds...))
}

func (s scaCommentLikeDo) Returning(value interface{}, columns ...string) IScaCommentLikeDo {
	return s.withDO(s.DO.Returning(value, columns...))
}

func (s scaCommentLikeDo) Not(conds ...gen.Condition) IScaCommentLikeDo {
	return s.withDO(s.DO.Not(conds...))
}

func (s scaCommentLikeDo) Or(conds ...gen.Condition) IScaCommentLikeDo {
	return s.withDO(s.DO.Or(conds...))
}

func (s scaCommentLikeDo) Select(conds ...field.Expr) IScaCommentLikeDo {
	return s.withDO(s.DO.Select(conds...))
}

func (s scaCommentLikeDo) Where(conds ...gen.Condition) IScaCommentLikeDo {
	return s.withDO(s.DO.Where(conds...))
}

func (s scaCommentLikeDo) Order(conds ...field.Expr) IScaCommentLikeDo {
	return s.withDO(s.DO.Order(conds...))
}

func (s scaCommentLikeDo) Distinct(cols ...field.Expr) IScaCommentLikeDo {
	return s.withDO(s.DO.Distinct(cols...))
}

func (s scaCommentLikeDo) Omit(cols ...field.Expr) IScaCommentLikeDo {
	return s.withDO(s.DO.Omit(cols...))
}

func (s scaCommentLikeDo) Join(table schema.Tabler, on ...field.Expr) IScaCommentLikeDo {
	return s.withDO(s.DO.Join(table, on...))
}

func (s scaCommentLikeDo) LeftJoin(table schema.Tabler, on ...field.Expr) IScaCommentLikeDo {
	return s.withDO(s.DO.LeftJoin(table, on...))
}

func (s scaCommentLikeDo) RightJoin(table schema.Tabler, on ...field.Expr) IScaCommentLikeDo {
	return s.withDO(s.DO.RightJoin(table, on...))
}

func (s scaCommentLikeDo) Group(cols ...field.Expr) IScaCommentLikeDo {
	return s.withDO(s.DO.Group(cols...))
}

func (s scaCommentLikeDo) Having(conds ...gen.Condition) IScaCommentLikeDo {
	return s.withDO(s.DO.Having(conds...))
}

func (s scaCommentLikeDo) Limit(limit int) IScaCommentLikeDo {
	return s.withDO(s.DO.Limit(limit))
}

func (s scaCommentLikeDo) Offset(offset int) IScaCommentLikeDo {
	return s.withDO(s.DO.Offset(offset))
}

func (s scaCommentLikeDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IScaCommentLikeDo {
	return s.withDO(s.DO.Scopes(funcs...))
}

func (s scaCommentLikeDo) Unscoped() IScaCommentLikeDo {
	return s.withDO(s.DO.Unscoped())
}

func (s scaCommentLikeDo) Create(values ...*model.ScaCommentLike) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Create(values)
}

func (s scaCommentLikeDo) CreateInBatches(values []*model.ScaCommentLike, batchSize int) error {
	return s.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (s scaCommentLikeDo) Save(values ...*model.ScaCommentLike) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Save(values)
}

func (s scaCommentLikeDo) First() (*model.ScaCommentLike, error) {
	if result, err := s.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.ScaCommentLike), nil
	}
}

func (s scaCommentLikeDo) Take() (*model.ScaCommentLike, error) {
	if result, err := s.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.ScaCommentLike), nil
	}
}

func (s scaCommentLikeDo) Last() (*model.ScaCommentLike, error) {
	if result, err := s.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.ScaCommentLike), nil
	}
}

func (s scaCommentLikeDo) Find() ([]*model.ScaCommentLike, error) {
	result, err := s.DO.Find()
	return result.([]*model.ScaCommentLike), err
}

func (s scaCommentLikeDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ScaCommentLike, err error) {
	buf := make([]*model.ScaCommentLike, 0, batchSize)
	err = s.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (s scaCommentLikeDo) FindInBatches(result *[]*model.ScaCommentLike, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return s.DO.FindInBatches(result, batchSize, fc)
}

func (s scaCommentLikeDo) Attrs(attrs ...field.AssignExpr) IScaCommentLikeDo {
	return s.withDO(s.DO.Attrs(attrs...))
}

func (s scaCommentLikeDo) Assign(attrs ...field.AssignExpr) IScaCommentLikeDo {
	return s.withDO(s.DO.Assign(attrs...))
}

func (s scaCommentLikeDo) Joins(fields ...field.RelationField) IScaCommentLikeDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Joins(_f))
	}
	return &s
}

func (s scaCommentLikeDo) Preload(fields ...field.RelationField) IScaCommentLikeDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Preload(_f))
	}
	return &s
}

func (s scaCommentLikeDo) FirstOrInit() (*model.ScaCommentLike, error) {
	if result, err := s.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.ScaCommentLike), nil
	}
}

func (s scaCommentLikeDo) FirstOrCreate() (*model.ScaCommentLike, error) {
	if result, err := s.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.ScaCommentLike), nil
	}
}

func (s scaCommentLikeDo) FindByPage(offset int, limit int) (result []*model.ScaCommentLike, count int64, err error) {
	result, err = s.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = s.Offset(-1).Limit(-1).Count()
	return
}

func (s scaCommentLikeDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = s.Count()
	if err != nil {
		return
	}

	err = s.Offset(offset).Limit(limit).Scan(result)
	return
}

func (s scaCommentLikeDo) Scan(result interface{}) (err error) {
	return s.DO.Scan(result)
}

func (s scaCommentLikeDo) Delete(models ...*model.ScaCommentLike) (result gen.ResultInfo, err error) {
	return s.DO.Delete(models)
}

func (s *scaCommentLikeDo) withDO(do gen.Dao) *scaCommentLikeDo {
	s.DO = *do.(*gen.DO)
	return s
}
