// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"
	"schisandra-album-cloud-microservices/app/community/api/model/mysql/model"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"
)

func newScaUserFollow(db *gorm.DB, opts ...gen.DOOption) scaUserFollow {
	_scaUserFollow := scaUserFollow{}

	_scaUserFollow.scaUserFollowDo.UseDB(db, opts...)
	_scaUserFollow.scaUserFollowDo.UseModel(&model.ScaUserFollow{})

	tableName := _scaUserFollow.scaUserFollowDo.TableName()
	_scaUserFollow.ALL = field.NewAsterisk(tableName)
	_scaUserFollow.FollowerID = field.NewString(tableName, "follower_id")
	_scaUserFollow.FolloweeID = field.NewString(tableName, "followee_id")
	_scaUserFollow.Status = field.NewInt64(tableName, "status")
	_scaUserFollow.CreatedAt = field.NewTime(tableName, "created_at")
	_scaUserFollow.UpdatedAt = field.NewTime(tableName, "updated_at")
	_scaUserFollow.ID = field.NewInt64(tableName, "id")
	_scaUserFollow.DeletedAt = field.NewField(tableName, "deleted_at")

	_scaUserFollow.fillFieldMap()

	return _scaUserFollow
}

type scaUserFollow struct {
	scaUserFollowDo

	ALL        field.Asterisk
	FollowerID field.String // 关注者
	FolloweeID field.String // 被关注者
	Status     field.Int64  // 关注状态（0 未互关 1 互关）
	CreatedAt  field.Time   // 创建时间
	UpdatedAt  field.Time   // 更新时间
	ID         field.Int64
	DeletedAt  field.Field // 删除时间

	fieldMap map[string]field.Expr
}

func (s scaUserFollow) Table(newTableName string) *scaUserFollow {
	s.scaUserFollowDo.UseTable(newTableName)
	return s.updateTableName(newTableName)
}

func (s scaUserFollow) As(alias string) *scaUserFollow {
	s.scaUserFollowDo.DO = *(s.scaUserFollowDo.As(alias).(*gen.DO))
	return s.updateTableName(alias)
}

func (s *scaUserFollow) updateTableName(table string) *scaUserFollow {
	s.ALL = field.NewAsterisk(table)
	s.FollowerID = field.NewString(table, "follower_id")
	s.FolloweeID = field.NewString(table, "followee_id")
	s.Status = field.NewInt64(table, "status")
	s.CreatedAt = field.NewTime(table, "created_at")
	s.UpdatedAt = field.NewTime(table, "updated_at")
	s.ID = field.NewInt64(table, "id")
	s.DeletedAt = field.NewField(table, "deleted_at")

	s.fillFieldMap()

	return s
}

func (s *scaUserFollow) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := s.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (s *scaUserFollow) fillFieldMap() {
	s.fieldMap = make(map[string]field.Expr, 7)
	s.fieldMap["follower_id"] = s.FollowerID
	s.fieldMap["followee_id"] = s.FolloweeID
	s.fieldMap["status"] = s.Status
	s.fieldMap["created_at"] = s.CreatedAt
	s.fieldMap["updated_at"] = s.UpdatedAt
	s.fieldMap["id"] = s.ID
	s.fieldMap["deleted_at"] = s.DeletedAt
}

func (s scaUserFollow) clone(db *gorm.DB) scaUserFollow {
	s.scaUserFollowDo.ReplaceConnPool(db.Statement.ConnPool)
	return s
}

func (s scaUserFollow) replaceDB(db *gorm.DB) scaUserFollow {
	s.scaUserFollowDo.ReplaceDB(db)
	return s
}

type scaUserFollowDo struct{ gen.DO }

type IScaUserFollowDo interface {
	gen.SubQuery
	Debug() IScaUserFollowDo
	WithContext(ctx context.Context) IScaUserFollowDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IScaUserFollowDo
	WriteDB() IScaUserFollowDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IScaUserFollowDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IScaUserFollowDo
	Not(conds ...gen.Condition) IScaUserFollowDo
	Or(conds ...gen.Condition) IScaUserFollowDo
	Select(conds ...field.Expr) IScaUserFollowDo
	Where(conds ...gen.Condition) IScaUserFollowDo
	Order(conds ...field.Expr) IScaUserFollowDo
	Distinct(cols ...field.Expr) IScaUserFollowDo
	Omit(cols ...field.Expr) IScaUserFollowDo
	Join(table schema.Tabler, on ...field.Expr) IScaUserFollowDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IScaUserFollowDo
	RightJoin(table schema.Tabler, on ...field.Expr) IScaUserFollowDo
	Group(cols ...field.Expr) IScaUserFollowDo
	Having(conds ...gen.Condition) IScaUserFollowDo
	Limit(limit int) IScaUserFollowDo
	Offset(offset int) IScaUserFollowDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IScaUserFollowDo
	Unscoped() IScaUserFollowDo
	Create(values ...*model.ScaUserFollow) error
	CreateInBatches(values []*model.ScaUserFollow, batchSize int) error
	Save(values ...*model.ScaUserFollow) error
	First() (*model.ScaUserFollow, error)
	Take() (*model.ScaUserFollow, error)
	Last() (*model.ScaUserFollow, error)
	Find() ([]*model.ScaUserFollow, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ScaUserFollow, err error)
	FindInBatches(result *[]*model.ScaUserFollow, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.ScaUserFollow) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IScaUserFollowDo
	Assign(attrs ...field.AssignExpr) IScaUserFollowDo
	Joins(fields ...field.RelationField) IScaUserFollowDo
	Preload(fields ...field.RelationField) IScaUserFollowDo
	FirstOrInit() (*model.ScaUserFollow, error)
	FirstOrCreate() (*model.ScaUserFollow, error)
	FindByPage(offset int, limit int) (result []*model.ScaUserFollow, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IScaUserFollowDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (s scaUserFollowDo) Debug() IScaUserFollowDo {
	return s.withDO(s.DO.Debug())
}

func (s scaUserFollowDo) WithContext(ctx context.Context) IScaUserFollowDo {
	return s.withDO(s.DO.WithContext(ctx))
}

func (s scaUserFollowDo) ReadDB() IScaUserFollowDo {
	return s.Clauses(dbresolver.Read)
}

func (s scaUserFollowDo) WriteDB() IScaUserFollowDo {
	return s.Clauses(dbresolver.Write)
}

func (s scaUserFollowDo) Session(config *gorm.Session) IScaUserFollowDo {
	return s.withDO(s.DO.Session(config))
}

func (s scaUserFollowDo) Clauses(conds ...clause.Expression) IScaUserFollowDo {
	return s.withDO(s.DO.Clauses(conds...))
}

func (s scaUserFollowDo) Returning(value interface{}, columns ...string) IScaUserFollowDo {
	return s.withDO(s.DO.Returning(value, columns...))
}

func (s scaUserFollowDo) Not(conds ...gen.Condition) IScaUserFollowDo {
	return s.withDO(s.DO.Not(conds...))
}

func (s scaUserFollowDo) Or(conds ...gen.Condition) IScaUserFollowDo {
	return s.withDO(s.DO.Or(conds...))
}

func (s scaUserFollowDo) Select(conds ...field.Expr) IScaUserFollowDo {
	return s.withDO(s.DO.Select(conds...))
}

func (s scaUserFollowDo) Where(conds ...gen.Condition) IScaUserFollowDo {
	return s.withDO(s.DO.Where(conds...))
}

func (s scaUserFollowDo) Order(conds ...field.Expr) IScaUserFollowDo {
	return s.withDO(s.DO.Order(conds...))
}

func (s scaUserFollowDo) Distinct(cols ...field.Expr) IScaUserFollowDo {
	return s.withDO(s.DO.Distinct(cols...))
}

func (s scaUserFollowDo) Omit(cols ...field.Expr) IScaUserFollowDo {
	return s.withDO(s.DO.Omit(cols...))
}

func (s scaUserFollowDo) Join(table schema.Tabler, on ...field.Expr) IScaUserFollowDo {
	return s.withDO(s.DO.Join(table, on...))
}

func (s scaUserFollowDo) LeftJoin(table schema.Tabler, on ...field.Expr) IScaUserFollowDo {
	return s.withDO(s.DO.LeftJoin(table, on...))
}

func (s scaUserFollowDo) RightJoin(table schema.Tabler, on ...field.Expr) IScaUserFollowDo {
	return s.withDO(s.DO.RightJoin(table, on...))
}

func (s scaUserFollowDo) Group(cols ...field.Expr) IScaUserFollowDo {
	return s.withDO(s.DO.Group(cols...))
}

func (s scaUserFollowDo) Having(conds ...gen.Condition) IScaUserFollowDo {
	return s.withDO(s.DO.Having(conds...))
}

func (s scaUserFollowDo) Limit(limit int) IScaUserFollowDo {
	return s.withDO(s.DO.Limit(limit))
}

func (s scaUserFollowDo) Offset(offset int) IScaUserFollowDo {
	return s.withDO(s.DO.Offset(offset))
}

func (s scaUserFollowDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IScaUserFollowDo {
	return s.withDO(s.DO.Scopes(funcs...))
}

func (s scaUserFollowDo) Unscoped() IScaUserFollowDo {
	return s.withDO(s.DO.Unscoped())
}

func (s scaUserFollowDo) Create(values ...*model.ScaUserFollow) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Create(values)
}

func (s scaUserFollowDo) CreateInBatches(values []*model.ScaUserFollow, batchSize int) error {
	return s.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (s scaUserFollowDo) Save(values ...*model.ScaUserFollow) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Save(values)
}

func (s scaUserFollowDo) First() (*model.ScaUserFollow, error) {
	if result, err := s.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.ScaUserFollow), nil
	}
}

func (s scaUserFollowDo) Take() (*model.ScaUserFollow, error) {
	if result, err := s.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.ScaUserFollow), nil
	}
}

func (s scaUserFollowDo) Last() (*model.ScaUserFollow, error) {
	if result, err := s.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.ScaUserFollow), nil
	}
}

func (s scaUserFollowDo) Find() ([]*model.ScaUserFollow, error) {
	result, err := s.DO.Find()
	return result.([]*model.ScaUserFollow), err
}

func (s scaUserFollowDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ScaUserFollow, err error) {
	buf := make([]*model.ScaUserFollow, 0, batchSize)
	err = s.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (s scaUserFollowDo) FindInBatches(result *[]*model.ScaUserFollow, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return s.DO.FindInBatches(result, batchSize, fc)
}

func (s scaUserFollowDo) Attrs(attrs ...field.AssignExpr) IScaUserFollowDo {
	return s.withDO(s.DO.Attrs(attrs...))
}

func (s scaUserFollowDo) Assign(attrs ...field.AssignExpr) IScaUserFollowDo {
	return s.withDO(s.DO.Assign(attrs...))
}

func (s scaUserFollowDo) Joins(fields ...field.RelationField) IScaUserFollowDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Joins(_f))
	}
	return &s
}

func (s scaUserFollowDo) Preload(fields ...field.RelationField) IScaUserFollowDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Preload(_f))
	}
	return &s
}

func (s scaUserFollowDo) FirstOrInit() (*model.ScaUserFollow, error) {
	if result, err := s.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.ScaUserFollow), nil
	}
}

func (s scaUserFollowDo) FirstOrCreate() (*model.ScaUserFollow, error) {
	if result, err := s.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.ScaUserFollow), nil
	}
}

func (s scaUserFollowDo) FindByPage(offset int, limit int) (result []*model.ScaUserFollow, count int64, err error) {
	result, err = s.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = s.Offset(-1).Limit(-1).Count()
	return
}

func (s scaUserFollowDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = s.Count()
	if err != nil {
		return
	}

	err = s.Offset(offset).Limit(limit).Scan(result)
	return
}

func (s scaUserFollowDo) Scan(result interface{}) (err error) {
	return s.DO.Scan(result)
}

func (s scaUserFollowDo) Delete(models ...*model.ScaUserFollow) (result gen.ResultInfo, err error) {
	return s.DO.Delete(models)
}

func (s *scaUserFollowDo) withDO(do gen.Dao) *scaUserFollowDo {
	s.DO = *do.(*gen.DO)
	return s
}
