// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"schisandra-album-cloud-microservices/common/ent/migrate"

	"schisandra-album-cloud-microservices/common/ent/scaauthpermissionrule"
	"schisandra-album-cloud-microservices/common/ent/scaauthrole"
	"schisandra-album-cloud-microservices/common/ent/scaauthuser"
	"schisandra-album-cloud-microservices/common/ent/scaauthuserdevice"
	"schisandra-album-cloud-microservices/common/ent/scaauthusersocial"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// ScaAuthPermissionRule is the client for interacting with the ScaAuthPermissionRule builders.
	ScaAuthPermissionRule *ScaAuthPermissionRuleClient
	// ScaAuthRole is the client for interacting with the ScaAuthRole builders.
	ScaAuthRole *ScaAuthRoleClient
	// ScaAuthUser is the client for interacting with the ScaAuthUser builders.
	ScaAuthUser *ScaAuthUserClient
	// ScaAuthUserDevice is the client for interacting with the ScaAuthUserDevice builders.
	ScaAuthUserDevice *ScaAuthUserDeviceClient
	// ScaAuthUserSocial is the client for interacting with the ScaAuthUserSocial builders.
	ScaAuthUserSocial *ScaAuthUserSocialClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.ScaAuthPermissionRule = NewScaAuthPermissionRuleClient(c.config)
	c.ScaAuthRole = NewScaAuthRoleClient(c.config)
	c.ScaAuthUser = NewScaAuthUserClient(c.config)
	c.ScaAuthUserDevice = NewScaAuthUserDeviceClient(c.config)
	c.ScaAuthUserSocial = NewScaAuthUserSocialClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                   ctx,
		config:                cfg,
		ScaAuthPermissionRule: NewScaAuthPermissionRuleClient(cfg),
		ScaAuthRole:           NewScaAuthRoleClient(cfg),
		ScaAuthUser:           NewScaAuthUserClient(cfg),
		ScaAuthUserDevice:     NewScaAuthUserDeviceClient(cfg),
		ScaAuthUserSocial:     NewScaAuthUserSocialClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                   ctx,
		config:                cfg,
		ScaAuthPermissionRule: NewScaAuthPermissionRuleClient(cfg),
		ScaAuthRole:           NewScaAuthRoleClient(cfg),
		ScaAuthUser:           NewScaAuthUserClient(cfg),
		ScaAuthUserDevice:     NewScaAuthUserDeviceClient(cfg),
		ScaAuthUserSocial:     NewScaAuthUserSocialClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		ScaAuthPermissionRule.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.ScaAuthPermissionRule.Use(hooks...)
	c.ScaAuthRole.Use(hooks...)
	c.ScaAuthUser.Use(hooks...)
	c.ScaAuthUserDevice.Use(hooks...)
	c.ScaAuthUserSocial.Use(hooks...)
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	c.ScaAuthPermissionRule.Intercept(interceptors...)
	c.ScaAuthRole.Intercept(interceptors...)
	c.ScaAuthUser.Intercept(interceptors...)
	c.ScaAuthUserDevice.Intercept(interceptors...)
	c.ScaAuthUserSocial.Intercept(interceptors...)
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *ScaAuthPermissionRuleMutation:
		return c.ScaAuthPermissionRule.mutate(ctx, m)
	case *ScaAuthRoleMutation:
		return c.ScaAuthRole.mutate(ctx, m)
	case *ScaAuthUserMutation:
		return c.ScaAuthUser.mutate(ctx, m)
	case *ScaAuthUserDeviceMutation:
		return c.ScaAuthUserDevice.mutate(ctx, m)
	case *ScaAuthUserSocialMutation:
		return c.ScaAuthUserSocial.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// ScaAuthPermissionRuleClient is a client for the ScaAuthPermissionRule schema.
type ScaAuthPermissionRuleClient struct {
	config
}

// NewScaAuthPermissionRuleClient returns a client for the ScaAuthPermissionRule from the given config.
func NewScaAuthPermissionRuleClient(c config) *ScaAuthPermissionRuleClient {
	return &ScaAuthPermissionRuleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `scaauthpermissionrule.Hooks(f(g(h())))`.
func (c *ScaAuthPermissionRuleClient) Use(hooks ...Hook) {
	c.hooks.ScaAuthPermissionRule = append(c.hooks.ScaAuthPermissionRule, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `scaauthpermissionrule.Intercept(f(g(h())))`.
func (c *ScaAuthPermissionRuleClient) Intercept(interceptors ...Interceptor) {
	c.inters.ScaAuthPermissionRule = append(c.inters.ScaAuthPermissionRule, interceptors...)
}

// Create returns a builder for creating a ScaAuthPermissionRule entity.
func (c *ScaAuthPermissionRuleClient) Create() *ScaAuthPermissionRuleCreate {
	mutation := newScaAuthPermissionRuleMutation(c.config, OpCreate)
	return &ScaAuthPermissionRuleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ScaAuthPermissionRule entities.
func (c *ScaAuthPermissionRuleClient) CreateBulk(builders ...*ScaAuthPermissionRuleCreate) *ScaAuthPermissionRuleCreateBulk {
	return &ScaAuthPermissionRuleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ScaAuthPermissionRuleClient) MapCreateBulk(slice any, setFunc func(*ScaAuthPermissionRuleCreate, int)) *ScaAuthPermissionRuleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ScaAuthPermissionRuleCreateBulk{err: fmt.Errorf("calling to ScaAuthPermissionRuleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ScaAuthPermissionRuleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ScaAuthPermissionRuleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ScaAuthPermissionRule.
func (c *ScaAuthPermissionRuleClient) Update() *ScaAuthPermissionRuleUpdate {
	mutation := newScaAuthPermissionRuleMutation(c.config, OpUpdate)
	return &ScaAuthPermissionRuleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScaAuthPermissionRuleClient) UpdateOne(sapr *ScaAuthPermissionRule) *ScaAuthPermissionRuleUpdateOne {
	mutation := newScaAuthPermissionRuleMutation(c.config, OpUpdateOne, withScaAuthPermissionRule(sapr))
	return &ScaAuthPermissionRuleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScaAuthPermissionRuleClient) UpdateOneID(id int64) *ScaAuthPermissionRuleUpdateOne {
	mutation := newScaAuthPermissionRuleMutation(c.config, OpUpdateOne, withScaAuthPermissionRuleID(id))
	return &ScaAuthPermissionRuleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ScaAuthPermissionRule.
func (c *ScaAuthPermissionRuleClient) Delete() *ScaAuthPermissionRuleDelete {
	mutation := newScaAuthPermissionRuleMutation(c.config, OpDelete)
	return &ScaAuthPermissionRuleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScaAuthPermissionRuleClient) DeleteOne(sapr *ScaAuthPermissionRule) *ScaAuthPermissionRuleDeleteOne {
	return c.DeleteOneID(sapr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ScaAuthPermissionRuleClient) DeleteOneID(id int64) *ScaAuthPermissionRuleDeleteOne {
	builder := c.Delete().Where(scaauthpermissionrule.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScaAuthPermissionRuleDeleteOne{builder}
}

// Query returns a query builder for ScaAuthPermissionRule.
func (c *ScaAuthPermissionRuleClient) Query() *ScaAuthPermissionRuleQuery {
	return &ScaAuthPermissionRuleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeScaAuthPermissionRule},
		inters: c.Interceptors(),
	}
}

// Get returns a ScaAuthPermissionRule entity by its id.
func (c *ScaAuthPermissionRuleClient) Get(ctx context.Context, id int64) (*ScaAuthPermissionRule, error) {
	return c.Query().Where(scaauthpermissionrule.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScaAuthPermissionRuleClient) GetX(ctx context.Context, id int64) *ScaAuthPermissionRule {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryScaAuthRole queries the sca_auth_role edge of a ScaAuthPermissionRule.
func (c *ScaAuthPermissionRuleClient) QueryScaAuthRole(sapr *ScaAuthPermissionRule) *ScaAuthRoleQuery {
	query := (&ScaAuthRoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sapr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scaauthpermissionrule.Table, scaauthpermissionrule.FieldID, id),
			sqlgraph.To(scaauthrole.Table, scaauthrole.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, scaauthpermissionrule.ScaAuthRoleTable, scaauthpermissionrule.ScaAuthRoleColumn),
		)
		fromV = sqlgraph.Neighbors(sapr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ScaAuthPermissionRuleClient) Hooks() []Hook {
	return c.hooks.ScaAuthPermissionRule
}

// Interceptors returns the client interceptors.
func (c *ScaAuthPermissionRuleClient) Interceptors() []Interceptor {
	return c.inters.ScaAuthPermissionRule
}

func (c *ScaAuthPermissionRuleClient) mutate(ctx context.Context, m *ScaAuthPermissionRuleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ScaAuthPermissionRuleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ScaAuthPermissionRuleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ScaAuthPermissionRuleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ScaAuthPermissionRuleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ScaAuthPermissionRule mutation op: %q", m.Op())
	}
}

// ScaAuthRoleClient is a client for the ScaAuthRole schema.
type ScaAuthRoleClient struct {
	config
}

// NewScaAuthRoleClient returns a client for the ScaAuthRole from the given config.
func NewScaAuthRoleClient(c config) *ScaAuthRoleClient {
	return &ScaAuthRoleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `scaauthrole.Hooks(f(g(h())))`.
func (c *ScaAuthRoleClient) Use(hooks ...Hook) {
	c.hooks.ScaAuthRole = append(c.hooks.ScaAuthRole, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `scaauthrole.Intercept(f(g(h())))`.
func (c *ScaAuthRoleClient) Intercept(interceptors ...Interceptor) {
	c.inters.ScaAuthRole = append(c.inters.ScaAuthRole, interceptors...)
}

// Create returns a builder for creating a ScaAuthRole entity.
func (c *ScaAuthRoleClient) Create() *ScaAuthRoleCreate {
	mutation := newScaAuthRoleMutation(c.config, OpCreate)
	return &ScaAuthRoleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ScaAuthRole entities.
func (c *ScaAuthRoleClient) CreateBulk(builders ...*ScaAuthRoleCreate) *ScaAuthRoleCreateBulk {
	return &ScaAuthRoleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ScaAuthRoleClient) MapCreateBulk(slice any, setFunc func(*ScaAuthRoleCreate, int)) *ScaAuthRoleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ScaAuthRoleCreateBulk{err: fmt.Errorf("calling to ScaAuthRoleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ScaAuthRoleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ScaAuthRoleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ScaAuthRole.
func (c *ScaAuthRoleClient) Update() *ScaAuthRoleUpdate {
	mutation := newScaAuthRoleMutation(c.config, OpUpdate)
	return &ScaAuthRoleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScaAuthRoleClient) UpdateOne(sar *ScaAuthRole) *ScaAuthRoleUpdateOne {
	mutation := newScaAuthRoleMutation(c.config, OpUpdateOne, withScaAuthRole(sar))
	return &ScaAuthRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScaAuthRoleClient) UpdateOneID(id int64) *ScaAuthRoleUpdateOne {
	mutation := newScaAuthRoleMutation(c.config, OpUpdateOne, withScaAuthRoleID(id))
	return &ScaAuthRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ScaAuthRole.
func (c *ScaAuthRoleClient) Delete() *ScaAuthRoleDelete {
	mutation := newScaAuthRoleMutation(c.config, OpDelete)
	return &ScaAuthRoleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScaAuthRoleClient) DeleteOne(sar *ScaAuthRole) *ScaAuthRoleDeleteOne {
	return c.DeleteOneID(sar.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ScaAuthRoleClient) DeleteOneID(id int64) *ScaAuthRoleDeleteOne {
	builder := c.Delete().Where(scaauthrole.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScaAuthRoleDeleteOne{builder}
}

// Query returns a query builder for ScaAuthRole.
func (c *ScaAuthRoleClient) Query() *ScaAuthRoleQuery {
	return &ScaAuthRoleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeScaAuthRole},
		inters: c.Interceptors(),
	}
}

// Get returns a ScaAuthRole entity by its id.
func (c *ScaAuthRoleClient) Get(ctx context.Context, id int64) (*ScaAuthRole, error) {
	return c.Query().Where(scaauthrole.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScaAuthRoleClient) GetX(ctx context.Context, id int64) *ScaAuthRole {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryScaAuthPermissionRule queries the sca_auth_permission_rule edge of a ScaAuthRole.
func (c *ScaAuthRoleClient) QueryScaAuthPermissionRule(sar *ScaAuthRole) *ScaAuthPermissionRuleQuery {
	query := (&ScaAuthPermissionRuleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sar.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scaauthrole.Table, scaauthrole.FieldID, id),
			sqlgraph.To(scaauthpermissionrule.Table, scaauthpermissionrule.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, scaauthrole.ScaAuthPermissionRuleTable, scaauthrole.ScaAuthPermissionRuleColumn),
		)
		fromV = sqlgraph.Neighbors(sar.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ScaAuthRoleClient) Hooks() []Hook {
	return c.hooks.ScaAuthRole
}

// Interceptors returns the client interceptors.
func (c *ScaAuthRoleClient) Interceptors() []Interceptor {
	return c.inters.ScaAuthRole
}

func (c *ScaAuthRoleClient) mutate(ctx context.Context, m *ScaAuthRoleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ScaAuthRoleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ScaAuthRoleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ScaAuthRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ScaAuthRoleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ScaAuthRole mutation op: %q", m.Op())
	}
}

// ScaAuthUserClient is a client for the ScaAuthUser schema.
type ScaAuthUserClient struct {
	config
}

// NewScaAuthUserClient returns a client for the ScaAuthUser from the given config.
func NewScaAuthUserClient(c config) *ScaAuthUserClient {
	return &ScaAuthUserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `scaauthuser.Hooks(f(g(h())))`.
func (c *ScaAuthUserClient) Use(hooks ...Hook) {
	c.hooks.ScaAuthUser = append(c.hooks.ScaAuthUser, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `scaauthuser.Intercept(f(g(h())))`.
func (c *ScaAuthUserClient) Intercept(interceptors ...Interceptor) {
	c.inters.ScaAuthUser = append(c.inters.ScaAuthUser, interceptors...)
}

// Create returns a builder for creating a ScaAuthUser entity.
func (c *ScaAuthUserClient) Create() *ScaAuthUserCreate {
	mutation := newScaAuthUserMutation(c.config, OpCreate)
	return &ScaAuthUserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ScaAuthUser entities.
func (c *ScaAuthUserClient) CreateBulk(builders ...*ScaAuthUserCreate) *ScaAuthUserCreateBulk {
	return &ScaAuthUserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ScaAuthUserClient) MapCreateBulk(slice any, setFunc func(*ScaAuthUserCreate, int)) *ScaAuthUserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ScaAuthUserCreateBulk{err: fmt.Errorf("calling to ScaAuthUserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ScaAuthUserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ScaAuthUserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ScaAuthUser.
func (c *ScaAuthUserClient) Update() *ScaAuthUserUpdate {
	mutation := newScaAuthUserMutation(c.config, OpUpdate)
	return &ScaAuthUserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScaAuthUserClient) UpdateOne(sau *ScaAuthUser) *ScaAuthUserUpdateOne {
	mutation := newScaAuthUserMutation(c.config, OpUpdateOne, withScaAuthUser(sau))
	return &ScaAuthUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScaAuthUserClient) UpdateOneID(id int64) *ScaAuthUserUpdateOne {
	mutation := newScaAuthUserMutation(c.config, OpUpdateOne, withScaAuthUserID(id))
	return &ScaAuthUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ScaAuthUser.
func (c *ScaAuthUserClient) Delete() *ScaAuthUserDelete {
	mutation := newScaAuthUserMutation(c.config, OpDelete)
	return &ScaAuthUserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScaAuthUserClient) DeleteOne(sau *ScaAuthUser) *ScaAuthUserDeleteOne {
	return c.DeleteOneID(sau.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ScaAuthUserClient) DeleteOneID(id int64) *ScaAuthUserDeleteOne {
	builder := c.Delete().Where(scaauthuser.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScaAuthUserDeleteOne{builder}
}

// Query returns a query builder for ScaAuthUser.
func (c *ScaAuthUserClient) Query() *ScaAuthUserQuery {
	return &ScaAuthUserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeScaAuthUser},
		inters: c.Interceptors(),
	}
}

// Get returns a ScaAuthUser entity by its id.
func (c *ScaAuthUserClient) Get(ctx context.Context, id int64) (*ScaAuthUser, error) {
	return c.Query().Where(scaauthuser.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScaAuthUserClient) GetX(ctx context.Context, id int64) *ScaAuthUser {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryScaAuthUserSocial queries the sca_auth_user_social edge of a ScaAuthUser.
func (c *ScaAuthUserClient) QueryScaAuthUserSocial(sau *ScaAuthUser) *ScaAuthUserSocialQuery {
	query := (&ScaAuthUserSocialClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sau.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scaauthuser.Table, scaauthuser.FieldID, id),
			sqlgraph.To(scaauthusersocial.Table, scaauthusersocial.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, scaauthuser.ScaAuthUserSocialTable, scaauthuser.ScaAuthUserSocialColumn),
		)
		fromV = sqlgraph.Neighbors(sau.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScaAuthUserDevice queries the sca_auth_user_device edge of a ScaAuthUser.
func (c *ScaAuthUserClient) QueryScaAuthUserDevice(sau *ScaAuthUser) *ScaAuthUserDeviceQuery {
	query := (&ScaAuthUserDeviceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sau.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scaauthuser.Table, scaauthuser.FieldID, id),
			sqlgraph.To(scaauthuserdevice.Table, scaauthuserdevice.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, scaauthuser.ScaAuthUserDeviceTable, scaauthuser.ScaAuthUserDeviceColumn),
		)
		fromV = sqlgraph.Neighbors(sau.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ScaAuthUserClient) Hooks() []Hook {
	return c.hooks.ScaAuthUser
}

// Interceptors returns the client interceptors.
func (c *ScaAuthUserClient) Interceptors() []Interceptor {
	return c.inters.ScaAuthUser
}

func (c *ScaAuthUserClient) mutate(ctx context.Context, m *ScaAuthUserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ScaAuthUserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ScaAuthUserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ScaAuthUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ScaAuthUserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ScaAuthUser mutation op: %q", m.Op())
	}
}

// ScaAuthUserDeviceClient is a client for the ScaAuthUserDevice schema.
type ScaAuthUserDeviceClient struct {
	config
}

// NewScaAuthUserDeviceClient returns a client for the ScaAuthUserDevice from the given config.
func NewScaAuthUserDeviceClient(c config) *ScaAuthUserDeviceClient {
	return &ScaAuthUserDeviceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `scaauthuserdevice.Hooks(f(g(h())))`.
func (c *ScaAuthUserDeviceClient) Use(hooks ...Hook) {
	c.hooks.ScaAuthUserDevice = append(c.hooks.ScaAuthUserDevice, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `scaauthuserdevice.Intercept(f(g(h())))`.
func (c *ScaAuthUserDeviceClient) Intercept(interceptors ...Interceptor) {
	c.inters.ScaAuthUserDevice = append(c.inters.ScaAuthUserDevice, interceptors...)
}

// Create returns a builder for creating a ScaAuthUserDevice entity.
func (c *ScaAuthUserDeviceClient) Create() *ScaAuthUserDeviceCreate {
	mutation := newScaAuthUserDeviceMutation(c.config, OpCreate)
	return &ScaAuthUserDeviceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ScaAuthUserDevice entities.
func (c *ScaAuthUserDeviceClient) CreateBulk(builders ...*ScaAuthUserDeviceCreate) *ScaAuthUserDeviceCreateBulk {
	return &ScaAuthUserDeviceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ScaAuthUserDeviceClient) MapCreateBulk(slice any, setFunc func(*ScaAuthUserDeviceCreate, int)) *ScaAuthUserDeviceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ScaAuthUserDeviceCreateBulk{err: fmt.Errorf("calling to ScaAuthUserDeviceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ScaAuthUserDeviceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ScaAuthUserDeviceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ScaAuthUserDevice.
func (c *ScaAuthUserDeviceClient) Update() *ScaAuthUserDeviceUpdate {
	mutation := newScaAuthUserDeviceMutation(c.config, OpUpdate)
	return &ScaAuthUserDeviceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScaAuthUserDeviceClient) UpdateOne(saud *ScaAuthUserDevice) *ScaAuthUserDeviceUpdateOne {
	mutation := newScaAuthUserDeviceMutation(c.config, OpUpdateOne, withScaAuthUserDevice(saud))
	return &ScaAuthUserDeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScaAuthUserDeviceClient) UpdateOneID(id int64) *ScaAuthUserDeviceUpdateOne {
	mutation := newScaAuthUserDeviceMutation(c.config, OpUpdateOne, withScaAuthUserDeviceID(id))
	return &ScaAuthUserDeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ScaAuthUserDevice.
func (c *ScaAuthUserDeviceClient) Delete() *ScaAuthUserDeviceDelete {
	mutation := newScaAuthUserDeviceMutation(c.config, OpDelete)
	return &ScaAuthUserDeviceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScaAuthUserDeviceClient) DeleteOne(saud *ScaAuthUserDevice) *ScaAuthUserDeviceDeleteOne {
	return c.DeleteOneID(saud.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ScaAuthUserDeviceClient) DeleteOneID(id int64) *ScaAuthUserDeviceDeleteOne {
	builder := c.Delete().Where(scaauthuserdevice.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScaAuthUserDeviceDeleteOne{builder}
}

// Query returns a query builder for ScaAuthUserDevice.
func (c *ScaAuthUserDeviceClient) Query() *ScaAuthUserDeviceQuery {
	return &ScaAuthUserDeviceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeScaAuthUserDevice},
		inters: c.Interceptors(),
	}
}

// Get returns a ScaAuthUserDevice entity by its id.
func (c *ScaAuthUserDeviceClient) Get(ctx context.Context, id int64) (*ScaAuthUserDevice, error) {
	return c.Query().Where(scaauthuserdevice.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScaAuthUserDeviceClient) GetX(ctx context.Context, id int64) *ScaAuthUserDevice {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryScaAuthUser queries the sca_auth_user edge of a ScaAuthUserDevice.
func (c *ScaAuthUserDeviceClient) QueryScaAuthUser(saud *ScaAuthUserDevice) *ScaAuthUserQuery {
	query := (&ScaAuthUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := saud.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scaauthuserdevice.Table, scaauthuserdevice.FieldID, id),
			sqlgraph.To(scaauthuser.Table, scaauthuser.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, scaauthuserdevice.ScaAuthUserTable, scaauthuserdevice.ScaAuthUserColumn),
		)
		fromV = sqlgraph.Neighbors(saud.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ScaAuthUserDeviceClient) Hooks() []Hook {
	return c.hooks.ScaAuthUserDevice
}

// Interceptors returns the client interceptors.
func (c *ScaAuthUserDeviceClient) Interceptors() []Interceptor {
	return c.inters.ScaAuthUserDevice
}

func (c *ScaAuthUserDeviceClient) mutate(ctx context.Context, m *ScaAuthUserDeviceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ScaAuthUserDeviceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ScaAuthUserDeviceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ScaAuthUserDeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ScaAuthUserDeviceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ScaAuthUserDevice mutation op: %q", m.Op())
	}
}

// ScaAuthUserSocialClient is a client for the ScaAuthUserSocial schema.
type ScaAuthUserSocialClient struct {
	config
}

// NewScaAuthUserSocialClient returns a client for the ScaAuthUserSocial from the given config.
func NewScaAuthUserSocialClient(c config) *ScaAuthUserSocialClient {
	return &ScaAuthUserSocialClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `scaauthusersocial.Hooks(f(g(h())))`.
func (c *ScaAuthUserSocialClient) Use(hooks ...Hook) {
	c.hooks.ScaAuthUserSocial = append(c.hooks.ScaAuthUserSocial, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `scaauthusersocial.Intercept(f(g(h())))`.
func (c *ScaAuthUserSocialClient) Intercept(interceptors ...Interceptor) {
	c.inters.ScaAuthUserSocial = append(c.inters.ScaAuthUserSocial, interceptors...)
}

// Create returns a builder for creating a ScaAuthUserSocial entity.
func (c *ScaAuthUserSocialClient) Create() *ScaAuthUserSocialCreate {
	mutation := newScaAuthUserSocialMutation(c.config, OpCreate)
	return &ScaAuthUserSocialCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ScaAuthUserSocial entities.
func (c *ScaAuthUserSocialClient) CreateBulk(builders ...*ScaAuthUserSocialCreate) *ScaAuthUserSocialCreateBulk {
	return &ScaAuthUserSocialCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ScaAuthUserSocialClient) MapCreateBulk(slice any, setFunc func(*ScaAuthUserSocialCreate, int)) *ScaAuthUserSocialCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ScaAuthUserSocialCreateBulk{err: fmt.Errorf("calling to ScaAuthUserSocialClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ScaAuthUserSocialCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ScaAuthUserSocialCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ScaAuthUserSocial.
func (c *ScaAuthUserSocialClient) Update() *ScaAuthUserSocialUpdate {
	mutation := newScaAuthUserSocialMutation(c.config, OpUpdate)
	return &ScaAuthUserSocialUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScaAuthUserSocialClient) UpdateOne(saus *ScaAuthUserSocial) *ScaAuthUserSocialUpdateOne {
	mutation := newScaAuthUserSocialMutation(c.config, OpUpdateOne, withScaAuthUserSocial(saus))
	return &ScaAuthUserSocialUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScaAuthUserSocialClient) UpdateOneID(id int64) *ScaAuthUserSocialUpdateOne {
	mutation := newScaAuthUserSocialMutation(c.config, OpUpdateOne, withScaAuthUserSocialID(id))
	return &ScaAuthUserSocialUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ScaAuthUserSocial.
func (c *ScaAuthUserSocialClient) Delete() *ScaAuthUserSocialDelete {
	mutation := newScaAuthUserSocialMutation(c.config, OpDelete)
	return &ScaAuthUserSocialDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScaAuthUserSocialClient) DeleteOne(saus *ScaAuthUserSocial) *ScaAuthUserSocialDeleteOne {
	return c.DeleteOneID(saus.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ScaAuthUserSocialClient) DeleteOneID(id int64) *ScaAuthUserSocialDeleteOne {
	builder := c.Delete().Where(scaauthusersocial.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScaAuthUserSocialDeleteOne{builder}
}

// Query returns a query builder for ScaAuthUserSocial.
func (c *ScaAuthUserSocialClient) Query() *ScaAuthUserSocialQuery {
	return &ScaAuthUserSocialQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeScaAuthUserSocial},
		inters: c.Interceptors(),
	}
}

// Get returns a ScaAuthUserSocial entity by its id.
func (c *ScaAuthUserSocialClient) Get(ctx context.Context, id int64) (*ScaAuthUserSocial, error) {
	return c.Query().Where(scaauthusersocial.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScaAuthUserSocialClient) GetX(ctx context.Context, id int64) *ScaAuthUserSocial {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryScaAuthUser queries the sca_auth_user edge of a ScaAuthUserSocial.
func (c *ScaAuthUserSocialClient) QueryScaAuthUser(saus *ScaAuthUserSocial) *ScaAuthUserQuery {
	query := (&ScaAuthUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := saus.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scaauthusersocial.Table, scaauthusersocial.FieldID, id),
			sqlgraph.To(scaauthuser.Table, scaauthuser.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, scaauthusersocial.ScaAuthUserTable, scaauthusersocial.ScaAuthUserColumn),
		)
		fromV = sqlgraph.Neighbors(saus.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ScaAuthUserSocialClient) Hooks() []Hook {
	return c.hooks.ScaAuthUserSocial
}

// Interceptors returns the client interceptors.
func (c *ScaAuthUserSocialClient) Interceptors() []Interceptor {
	return c.inters.ScaAuthUserSocial
}

func (c *ScaAuthUserSocialClient) mutate(ctx context.Context, m *ScaAuthUserSocialMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ScaAuthUserSocialCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ScaAuthUserSocialUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ScaAuthUserSocialUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ScaAuthUserSocialDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ScaAuthUserSocial mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		ScaAuthPermissionRule, ScaAuthRole, ScaAuthUser, ScaAuthUserDevice,
		ScaAuthUserSocial []ent.Hook
	}
	inters struct {
		ScaAuthPermissionRule, ScaAuthRole, ScaAuthUser, ScaAuthUserDevice,
		ScaAuthUserSocial []ent.Interceptor
	}
)
